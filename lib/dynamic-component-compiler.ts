// Dynamic Component Compiler for AI-generated components
// This module handles compiling and registering React components generated by AI

import React from 'react';
import * as Babel from '@babel/standalone';

// Import UI components for dynamic injection
import { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
// Add more UI components as needed ...

export interface GeneratedComponent {
  type: string;
  category: string;
  props: Record<string, any>;
  code: string;
}

export interface CompiledComponent {
  type: string;
  component: React.ComponentType<any>;
  props: Record<string, any>;
}

// In-memory registry for dynamically compiled components
const dynamicComponentRegistry = new Map<string, React.ComponentType<any>>();

// In-memory registry for compilation errors
const compilationErrorRegistry = new Map<string, { code: string; error: string }>();

// Registry for sample data for dynamic components
const dynamicComponentSampleData: Record<string, any> = {};

function toPascalCase(str: string) {
  return str
    .split('-')
    .map(s => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

/**
 * Safely compiles a React component from code string using Babel
 */
export function compileComponent(code: string, componentName: string): React.ComponentType<any> | null {
  try {
    // Remove any import/export statements (shouldn't be present, but just in case)
    code = code.replace(/import[^;]+;/g, '').replace(/export\s+(function|const|let|var|class)\s+/g, '$1 ');

    // Transform JSX to JS using Babel
    const transformed = Babel.transform(code, {
      presets: ['react'],
      filename: `${componentName}.jsx`,
    }).code;

    // Find the function name
    let funcName = '';
    let wrappedCode = '';
    const functionMatch = code.match(/function\s+([A-Za-z0-9_]+)\s*\(/);
    if (functionMatch) {
      funcName = functionMatch[1];
      wrappedCode = transformed + `; return ${funcName};`;
    } else {
      const arrowMatch = code.match(/(const|let|var)\s+([A-Za-z0-9_]+)\s*=\s*\(/);
      if (arrowMatch) {
        funcName = arrowMatch[2];
        wrappedCode = transformed + `; return ${funcName};`;
      }
    }
    if (!wrappedCode) {
      console.error('No function definition found in code');
      return null;
    }

    // Prepare dynamic component registry for dependency injection
    // Register a placeholder first to allow for mutual recursion
    dynamicComponentRegistry.set(componentName, undefined as any);

    // Get all dynamic component names (PascalCase) and their functions
    const dynamicNames = Array.from(dynamicComponentRegistry.keys())
      .filter(name => name !== componentName)
      .map(toPascalCase);
    const dynamicFns = Array.from(dynamicComponentRegistry.entries())
      .filter(([name]) => name !== componentName)
      .map(([, fn]) => fn);

    // Build the function signature and argument list
    const argNames = [
      'React',
      // UI components
      'Accordion', 'AccordionItem', 'AccordionTrigger', 'AccordionContent',
      'Button',
      'Card', 'CardHeader', 'CardFooter', 'CardTitle', 'CardDescription', 'CardContent',
      // Dynamic components
      ...dynamicNames
    ];
    const argValues = [
      require('react'),
      // UI components
      Accordion, AccordionItem, AccordionTrigger, AccordionContent,
      Button,
      Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent,
      // Dynamic components
      ...dynamicFns
    ];

    // Evaluate the function in a context where React and all dynamic components are available
    const Component = new Function(...argNames, wrappedCode)(...argValues);
    if (typeof Component === 'function') {
      // Wrap the AI-generated component in a dark theme container
      const WrappedComponent = function(props: any) {
        return React.createElement(
          'div',
          { className: 'dark bg-black text-white' },
          React.createElement(Component, props)
        );
      };
      // Update the registry with the actual function
      dynamicComponentRegistry.set(componentName, WrappedComponent);
      return WrappedComponent;
    }
    console.error('Compiled result is not a valid React component');
    return null;
  } catch (error) {
    console.error('Failed to compile component:', error);
    return null;
  }
}

/**
 * Registers a dynamically compiled component
 */
export function registerDynamicComponent(
  type: string,
  code: string,
  sampleData: any
): React.ComponentType<any> | null {
  const Component = compileComponent(code, type);
  if (Component) {
    dynamicComponentRegistry.set(type, Component);
    dynamicComponentSampleData[type] = sampleData;
    return Component;
  }
  return null;
}

/**
 * Gets a dynamically compiled component by type
 */
export function getDynamicComponent(type: string): React.ComponentType<any> | undefined {
  return dynamicComponentRegistry.get(type);
}

/**
 * Checks if a component type is registered dynamically
 */
export function isDynamicComponent(type: string): boolean {
  return dynamicComponentRegistry.has(type);
}

/**
 * Gets compilation error for a component type
 */
export function getCompilationError(type: string): { code: string; error: string } | undefined {
  return compilationErrorRegistry.get(type);
}

/**
 * Checks if a component type has a compilation error
 */
export function hasCompilationError(type: string): boolean {
  return compilationErrorRegistry.has(type);
}

/**
 * Compiles and registers a generated component
 */
export function compileAndRegisterComponent(generatedComponent: GeneratedComponent): boolean {
  const { type, code } = generatedComponent;
  
  console.log('=== COMPILATION START ===');
  console.log('Compiling component:', type);
  console.log('Component code:', code);
  
  console.log('Compiling component:', type);
  console.log('Component code:', code);
  
  // Try to extract the actual component name from the code
  let componentName = '';
  
  // Look for export function or export const patterns
  const exportFunctionMatch = code.match(/export\s+(?:function|const)\s+(\w+)/);
  if (exportFunctionMatch) {
    componentName = exportFunctionMatch[1];
    console.log('Found component name from export:', componentName);
  } else {
    // Fallback to kebab-case to PascalCase conversion
    componentName = type
      .split('-')
      .map(s => s.charAt(0).toUpperCase() + s.slice(1))
      .join('');
    console.log('Using fallback component name:', componentName);
  }
  
  // Clean up component name - remove "Missing" prefix if present
  if (componentName.startsWith('Missing')) {
    componentName = componentName.replace(/^Missing/, '');
    console.log('Cleaned up component name (removed Missing prefix):', componentName);
  }
  
  // If the component name doesn't match the type, use the extracted name
  if (componentName && componentName !== type) {
    console.log('Using extracted component name instead of type-based name');
  }
  
  // Also try to find any function declaration that might be our component
  const functionMatch = code.match(/function\s+(\w+)/);
  if (functionMatch && !componentName) {
    componentName = functionMatch[1];
    console.log('Found component name from function declaration:', componentName);
  }
  
  // If still no component name, try to find any capitalized function name
  if (!componentName) {
    const capitalizedFunctionMatch = code.match(/(\w+)\s*=\s*(?:React\.)?(?:memo\()?function/);
    if (capitalizedFunctionMatch) {
      componentName = capitalizedFunctionMatch[1];
      console.log('Found component name from capitalized function:', componentName);
    }
  }
  
  console.log('Final component name to compile:', componentName);
  
  // If we still don't have a component name, use the type as fallback
  if (!componentName) {
    componentName = type
      .split('-')
      .map(s => s.charAt(0).toUpperCase() + s.slice(1))
      .join('');
    console.log('Using type as fallback component name:', componentName);
  }
  
  try {
    const compiledComponent = compileComponent(code, componentName);
    
    if (compiledComponent) {
      registerDynamicComponent(type, code, generatedComponent.props); // Pass sample data
      console.log('=== COMPILATION SUCCESS ===');
      console.log('Successfully registered dynamic component:', type);
      return true;
    }
    
    // If compilation failed, store the error
    const error = `Failed to compile component ${type} - component is not a valid React function`;
    compilationErrorRegistry.set(type, { code, error });
    console.log('=== COMPILATION FAILED ===');
    console.error('Failed to compile component:', type);
    return false;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown compilation error';
    compilationErrorRegistry.set(type, { code, error: errorMessage });
    console.log('=== COMPILATION ERROR ===');
    console.error('Failed to compile component:', type, error);
    return false;
  }
}

/**
 * Creates a fallback component for compilation failures
 */
export function createCompilationFallbackComponent(type: string, code: string, error: string): React.ComponentType<any> {
  return function CompilationFallbackComponent(props: any) {
    return React.createElement('div', {
      className: "p-6 bg-red-500/20 border border-red-500/50 rounded-lg m-4"
    }, [
      React.createElement('div', {
        key: 'header',
        className: "flex items-center gap-2 mb-3"
      }, [
        React.createElement('div', {
          key: 'pulse',
          className: "w-3 h-3 bg-red-500 rounded-full animate-pulse"
        }),
        React.createElement('h3', {
          key: 'title',
          className: "text-lg font-semibold text-red-300"
        }, "Component Compilation Failed")
      ]),
      React.createElement('p', {
        key: 'description',
        className: "text-red-200 mb-3"
      }, [
        "Failed to compile component: ",
        React.createElement('code', {
          key: 'code',
          className: "bg-red-500/30 px-2 py-1 rounded"
        }, type)
      ]),
      React.createElement('p', {
        key: 'error',
        className: "text-red-300 mb-3 text-sm"
      }, error),
      React.createElement('details', {
        key: 'details',
        className: "text-sm"
      }, [
        React.createElement('summary', {
          key: 'summary',
          className: "cursor-pointer text-red-300 hover:text-red-200"
        }, "View Generated Code"),
        React.createElement('pre', {
          key: 'pre',
          className: "mt-2 p-3 bg-gray-800 rounded text-xs overflow-x-auto"
        }, [
          React.createElement('code', {
            key: 'code-block',
            className: "text-gray-300"
          }, code)
        ])
      ]),
      React.createElement('div', {
        key: 'props',
        className: "mt-3 p-3 bg-gray-800/50 rounded"
      }, [
        React.createElement('p', {
          key: 'props-text',
          className: "text-xs text-gray-400"
        }, `Props received: ${JSON.stringify(props, null, 2)}`)
      ])
    ]);
  };
}

/**
 * Creates a fallback component for failed compilations
 */
export function createFallbackComponent(type: string, errorMessage: string): React.ComponentType<any> {
  return function FallbackComponent(props: any) {
    return React.createElement('div', {
      className: "p-6 bg-yellow-500/20 border border-yellow-500/50 rounded-lg m-4"
    }, [
      React.createElement('div', {
        key: 'header',
        className: "flex items-center gap-2 mb-3"
      }, [
        React.createElement('div', {
          key: 'pulse',
          className: "w-3 h-3 bg-yellow-500 rounded-full animate-pulse"
        }),
        React.createElement('h3', {
          key: 'title',
          className: "text-lg font-semibold text-yellow-300"
        }, "Component Not Found")
      ]),
      React.createElement('p', {
        key: 'description',
        className: "text-yellow-200 mb-3"
      }, [
        errorMessage + ": ",
        React.createElement('code', {
          key: 'code',
          className: "bg-yellow-500/30 px-2 py-1 rounded"
        }, type)
      ]),
      React.createElement('div', {
        key: 'props',
        className: "mt-3 p-3 bg-gray-800/50 rounded"
      }, [
        React.createElement('p', {
          key: 'props-text',
          className: "text-xs text-gray-400"
        }, `Props received: ${JSON.stringify(props, null, 2)}`)
      ]),
      React.createElement('div', {
        key: 'help',
        className: "mt-3 p-3 bg-blue-500/20 rounded"
      }, [
        React.createElement('p', {
          key: 'help-text',
          className: "text-xs text-blue-300"
        }, "This component may need to be generated by AI or added to the component library.")
      ])
    ]);
  };
}

/**
 * Batch compile and register multiple generated components
 */
export function compileAndRegisterComponents(generatedComponents: GeneratedComponent[]): {
  success: string[];
  failed: string[];
} {
  const successList: string[] = [];
  const failedList: string[] = [];
  
  generatedComponents.forEach(genComponent => {
    const compilationSuccess = compileAndRegisterComponent(genComponent);
    if (compilationSuccess) {
      successList.push(genComponent.type);
    } else {
      failedList.push(genComponent.type);
    }
  });
  
  return { success: successList, failed: failedList };
}

/**
 * Clear all dynamically registered components
 */
export function clearDynamicComponents(): void {
  dynamicComponentRegistry.clear();
  console.log('Cleared all dynamic components');
}

/**
 * Get all registered dynamic component types
 */
export function getRegisteredDynamicComponentTypes(): string[] {
  return Array.from(dynamicComponentRegistry.keys());
} 

export function getDynamicComponentSampleData(type: string): any {
  return dynamicComponentSampleData[type];
} 